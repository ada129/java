1#На основе выполненной работы в предыдущей практике и следующих требований, сформировать структуру игрового проекта:
Класс GameObject является абстрактным и имеет два поля: идентификатор объекта (int) и имя объекта(String);
Интерфейс Damager определяет поведение предметов, наносящих урон и содержит сигнатуру метода getDamage(), возвращающего значение int; 
Класс Creature расширяет GameObject и является родителем для всех существ;
Класс Item расширяет GameObject и является базовым для любых предметов, которыми может владеть игрок;
Класс Equipment расширяет базовый класс предметов и является родителем для любой экипировки (то, что герой носит на себе в том числе оружие);
Класс EquipmentCell - класс-дженерик, который обрабатывает любые типы T расширяющие класс экипировки; по смыслу представляет собой ячейку, в которую размещается элемент экипировки.
Класс Inventory - класс-джереник, который обрабатывает типы T, расширяющие класс предметов. Класс описывает стандартный инвентарь игрока и содержит список объектов типа Item.
Интерфейс Lootable описывает поведение существ, с которых после убийства падают предметы и содержит сигнатуру метода dropLoot(), возвращающего список (List) объектов типа Item;
Интерфейс Attacker описывает поведение сущности, способной атаковать и содержит сигнатуру метода attack(Damageable target), который возвращает void;
Интерфейс Damageable описывает сущности или объекты, которым можно нанести урон и содержит сигнатуру метода getHit(Damager, damager);
Созданные классы в практике 1 соответствующим образом переписать под новую структуру с небольшими изменениями: Класс Character переименовать в Player, а Enemy - в Mob.
В данном задании необходимо подготовить только структуру классов
2#Теперь структуру классов надо заполнить основными свойствами и поведением, соответственно назначению классов, соблюдая логику наследования. Например, у всех существ есть здоровье, но не каждое существо умеет атаковать и имеет экипировку\оружее. 
Поэтому, задача будет считаться выполненной, если общие и частные свойства\поведения объектов будут правильно распределены по иерархии классов. 
Также не забыть о реализации соответствующих интерфейсов, например, для существа реализация интерфейса Damageable подразумевает уменьшение его здоровья в методе getHit(Damager damager). Объект, который реализует Damager - должен возвращать значение наносимого урона через метод getDamage(). 
health -= damager.getDamage();
3#Далее для функционирования базовой игровой логики необходимо создать класс GameLogic, содержащий статический метод void fight(Attacker attacker, Damagable target) для обмена уроном между двумя существами.
 После чего создать класс GameLoop в котором будет реализован игровой цикл с несколькими объектами типа оружия, существ и героя.
Количество мобов, их свойства, сила оружия, здоровье и т.д. заполняется случайным образом (как в практике 1).
Герой и моб получают своё оружие и далее идёт следующий цикл:
Герой наносит урон мобу
Если моб жив, то он наносит урон герою
Если моб погиб, то в инвентарь герою падает лут с моба (то есть вызов метода getLoot().
Повторять пока герой не победит всех мобов или не погибнет сам.
