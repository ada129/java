Задание 1. 
Настало время экспериментов! Создание игр подчиняется старой схеме, позаимствованной у великих иллюзионистов - дым и зеркала. И для придания иллюзии “живой” игры, необходимо сделать так, чтобы некоторые действия происходили параллельно, пока игрок продвигается по миру. А значит стоит задача внедрить многопоточность.
Для начала имеет смысл заселить игру существами, которые могут передвигаться независимо от действий пользователя.
Класс Creature описывает общее живое существо, у которого есть имя, здоровье, экипировка и базовая сила атаки (по-умолчанию равна 1 или случ.значению).
Экипировка описывается классом Equipment и у каждого существа есть список (ArrayList<Equipment>) с объектами этого класса.
Во время сражения, сила атаки существа рассчитывается через DPS. 

Пояснение: Данные для функции DPS должны браться из ArrayList-а с экипировкой существа.

Для управления существом как отдельным потоком выполнения используется класс CreatureController, реализующий интерфейс Runnable, который содержит в себе объект с ссылкой на конкретное существо и позволяет ему существовать в отдельном потоке, пока тот жив.


Пояснение: Конструктор CreatureController принимает в себя объект Creature (а если быть точнее, ссылку на объект) и присваивает его внутреннему полю класса, чтобы далее использовать в своих методах.

Что может делать существо в своём потоке: ожидать появление игрока и драться с игроком.
В качестве простейшего игрового пространства можно использовать двумерный массив символов Char[][], где игрок может отображаться символом “@”, а существа - первой буквой своего имени.

Пояснение: Используйте функцию name.charAt(0);

Чтобы удобно было ориентироваться в пространстве, имеет смысл использовать класс Position, с полями x, y, а также дополнительными методами работы с ним.

Что необходимо сделать в задании (с учётом условий выше):
Иерархию игровых объектов, начиная с GameObject и заканчивая Weapon и Mob;
Класс GameLogic со статическими методами для обработки различных игровых систем (DPS, бой, генерация оружия и т.д);
Игровое поле в виде 2D массива символов, где каждый объект имеет свою позицию;
Каждый противник использует свой контроллер для работы в отдельном потоке. Как только враг натыкается на игрока, то происходит битва. Также каждое существо обладает своей экипировкой (оружие и броня в виде объектов);
Персонаж игрока автоматически путешествует по игровому полю и автоматически сражается с противником. Если оружие или броня убитого противника лучше чем то, что носит игрок, то оно заменяет текущее;
Игровой цикл, который выполняется, пока игрок жив или пока не убиты все мобы на карте.
Способ генерации игровых переменных - рандомизация. 

Задание 2*.
Добавить автоматическое исцеление при помощи зелья. Зелья - это отдельный объект класса Potion. Персонаж игрока может подобрать зелье из убитого противника. Решение о принятии зелья должно основываться на показателях здоровья, которые считываются каждые несколько секунд.

Задание 3**.
Реализовать задание 2*, а также “базу” на которую персонаж возвращается после убийства всех мобов на карте. С базы игрок может уйти в автоматическую экспедицию, которая может принести одно из случайно сгенерированных вещей: оружие, броню, зелье.
Либо игрок вновь попадает на игровое поле с врагами.
